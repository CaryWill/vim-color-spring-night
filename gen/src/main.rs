#[macro_use]
extern crate lazy_static;

use std::collections::HashMap;
use std::fmt::Display;
use std::io;

#[derive(Debug)]
enum ColorCode<T: Display> {
    Normal(T),
    Contrast(T, T),
}

impl<T: Display> ColorCode<T> {
    fn normal(&self) -> &T {
        match self {
            ColorCode::Normal(c) => c,
            ColorCode::Contrast(h, _) => h,
        }
    }
}

const NONE_COLOR: ColorCode<&'static str> = ColorCode::Normal("NONE");

#[derive(Debug)]
struct Color {
    gui: ColorCode<&'static str>,
    cterm: ColorCode<u8>,
}

type ColorTable = HashMap<&'static str, Color>;

type ColorName = Option<&'static str>;

#[derive(Debug, PartialEq)]
enum HighlightAttr {
    Nothing,
    Bold,
    Italic,
    Underline,
    Reverse,
    None,
    CommentItalic,
    Undercurl,
}

#[derive(Debug)]
struct Highlight {
    name: &'static str,
    fg: ColorName,
    bg: ColorName,
    sp: ColorName,
    attr: HighlightAttr,
}

#[derive(Debug)]
enum HowToHighlight {
    Always(Highlight),
    Switch(Highlight, Highlight),
}

use HowToHighlight::Always;
use HowToHighlight::Switch;

macro_rules! fgbg {
    ($name:expr, - , - , $attr:ident) => {
        Highlight {
            name: $name,
            fg: None,
            bg: None,
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, - , $bg:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: None,
            bg: Some(stringify!($bg)),
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, $fg:ident, - , $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: None,
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, $fg:ident, $bg:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: Some(stringify!($bg)),
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
}

macro_rules! fgbgsp {
    ($name:expr, $fg:ident,NONE, $sp:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: None,
            sp: Some(stringify!($sp)),
            attr: HighlightAttr::$attr,
        }
    };
}

fn write_header<O: io::Write>(out: &mut O, name: &'static str) -> io::Result<()> {
    write!(
        out,
        r#"" {name}: Calm-colored dark color scheme
"
" Author: rhysd <lin90162@yahoo.co.jp>
" License: MIT
"   Copyright (c) 2016 rhysd
"
" THIS FILE WAS GENERATED BY SCRIPT. PLEASE DO NOT MODIFY DIRECTLY!

" Optimization:
" `:set background=dark` has some side effects which takes a time.
" Avoid the side effects when the value is already 'dark'.
if &background !=# 'dark'
    set background=dark
endif

" Optimization:
" `:hi clear` takes a lot of time since it clears all highlights and set default
" highlights. This guard avoids `:hi clear` on loading vimrc since in almost
" all cases no additional highlight is set at start up. Almost all additional
" highlights are set by Vim plugins.
if !has('vim_starting')
    " Remove all existing highlighting and set the defaults.
    hi clear
endif

if exists('g:syntax_on')
    syntax reset
endif

let g:colors_name = '{name}'

let s:gui_running = has('gui_running')
let s:true_colors = has('termguicolors') && &termguicolors
let s:undercurl = s:gui_running ? 'undercurl' : 'underline'

let g:spring_night_italic_comments = get(g:, 'spring_night_italic_comments', 0)
let g:spring_night_kill_italic = get(g:, 'spring_night_kill_italic', 0)
let g:spring_night_kill_bold = get(g:, 'spring_night_kill_bold', 0)
let g:spring_night_highlight_terminal = get(g:, 'spring_night_highlight_terminal', 1)

if exists('g:spring_night_high_contrast')
    if type(g:spring_night_high_contrast) != type(0)
        echoerr 'g:spring_night_high_contrast must be number. Please read README.md of vim-color-spring-night repository'
    endif
else
    let g:spring_night_high_contrast = !s:gui_running && s:true_colors
endif

"#,
        name = name
    )
}

fn write_contrast_color_variables<O: io::Write>(out: &mut O, table: &ColorTable) -> io::Result<()> {
    for (name, color) in table.iter() {
        if let ColorCode::Contrast(high, low) = color.gui {
            writeln!(
                out,
                "let s:{}_gui = g:spring_night_high_contrast ? '{}' : '{}'",
                name, high, low
            )?;
        }
        if let ColorCode::Contrast(high, low) = color.cterm {
            writeln!(
                out,
                "let s:{}_cterm = g:spring_night_high_contrast ? '{}' : '{}'",
                name, high, low
            )?;
        }
    }
    writeln!(out, "")
}

fn build_highlight_item<T: Display>(
    color_name: &'static str,
    item_name: &'static str,
    color: &ColorCode<T>,
) -> String {
    match color {
        ColorCode::Normal(c) => format!("{}={}", item_name, c),
        ColorCode::Contrast(..) => if item_name.starts_with("gui") {
            format!("'{}='.s:{}_gui", item_name, color_name)
        } else {
            format!("'{}='.s:{}_cterm", item_name, color_name)
        },
    }
}

fn write_highlight<O: io::Write>(
    out: &mut O,
    highlight: &Highlight,
    table: &ColorTable,
    indent: u32,
) -> io::Result<()> {
    let mut args = vec![highlight.name.to_string(), "term=NONE".to_string()];

    for &(color_name, gui, cterm) in &[
        (&highlight.fg, "guifg", "ctermfg"),
        (&highlight.bg, "guibg", "ctermbg"),
    ] {
        if let Some(ref name) = color_name {
            if name != &"NONE" {
                let color = table.get(name).unwrap();
                args.push(build_highlight_item(name, gui, &color.gui));
                args.push(build_highlight_item(name, cterm, &color.cterm));
            } else {
                args.push(build_highlight_item(name, gui, &NONE_COLOR));
                args.push(build_highlight_item(name, cterm, &NONE_COLOR));
            }
        }
    }

    if let Some(ref name) = highlight.sp {
        // Note: ctermsp does not exist
        args.push(build_highlight_item(
            name,
            "guisp",
            &table.get(name).unwrap().gui, // Currently guisp must not be NONE
        ));
    }

    let attr_item = match highlight.attr {
        HighlightAttr::Nothing => "",
        HighlightAttr::Bold => "!g:spring_night_kill_bold ? 'gui=bold cterm=bold' : ''",
        HighlightAttr::Italic => "!g:spring_night_kill_italic ? 'gui=italic' : ''",
        HighlightAttr::Underline => "gui=underline cterm=underline",
        HighlightAttr::Reverse => "gui=reverse cterm=reverse",
        HighlightAttr::None => "gui=NONE cterm=NONE",
        HighlightAttr::CommentItalic => {
            "g:spring_night_italic_comments && !g:spring_night_kill_italic ? 'gui=italic' : ''"
        }
        HighlightAttr::Undercurl => "'gui='.s:undercurl 'cterm='.s:undercurl",
    };
    if attr_item != "" {
        args.push(attr_item.to_string());
    }

    let indent = match indent {
        0u32 => "",
        1u32 => "    ",
        _ => unreachable!(),
    };

    if args
        .iter()
        .any(|a| a.starts_with('\'') || a.ends_with('\''))
    {
        for arg in args.iter_mut() {
            if !arg.starts_with('\'') && !arg.ends_with('\'') {
                *arg = format!("'{}'", arg);
            }
        }
        writeln!(out, "{}exe 'hi' {}", indent, args.join(" "))
    } else {
        writeln!(out, "{}hi {}", indent, args.join(" "))
    }
}

fn write_highlights<O: io::Write>(out: &mut O, table: &ColorTable) -> io::Result<()> {
    for highlight in HIGHLIGHTS {
        match highlight {
            Always(ref hl) => write_highlight(out, hl, table, 0u32)?,
            Switch(ref gui, ref term) => {
                writeln!(out, "if s:gui_running")?;
                write_highlight(out, gui, table, 1u32)?;
                writeln!(out, "else")?;
                write_highlight(out, term, table, 1u32)?;
                writeln!(out, "endif")?;
            }
        }
    }
    writeln!(out, "")
}

fn write_term_colors<O: io::Write>(out: &mut O, table: &ColorTable) -> io::Result<()> {
    writeln!(out, "if has('nvim')")?;
    writeln!(out, "    if s:gui_running || s:true_colors")?;
    for (index, name) in TERM_COLORS.iter().enumerate() {
        writeln!(
            out,
            "        let g:terminal_color_{} = '{}'",
            index,
            table.get(name).unwrap().gui.normal()
        )?;
    }
    writeln!(out, "    else")?;
    for (index, name) in TERM_COLORS.iter().enumerate() {
        writeln!(
            out,
            "        let g:terminal_color_{} = {}",
            index,
            table.get(name).unwrap().cterm.normal()
        )?;
    }
    writeln!(out, "    endif")?;
    writeln!(out, "else")?;
    writeln!(out, "    let g:terminal_ansi_colors = [")?;
    for name in TERM_COLORS.iter() {
        writeln!(out, "\\       '{}',", table.get(name).unwrap().gui.normal())?;
    }
    writeln!(out, "\\   ]")?;
    writeln!(out, "endif")
}

fn write_color_scheme<O: io::Write>(out: &mut O, table: &ColorTable) -> io::Result<()> {
    write_header(out, "spring-night")?;
    write_contrast_color_variables(out, table)?;
    write_highlights(out, table)?;
    write_term_colors(out, table)
}

lazy_static! {
    #[cfg_attr(rustfmt, rustfmt_skip)]
    static ref COLOR_TABLE: ColorTable = {
        fn color(gui: ColorCode<&'static str>, cterm: ColorCode<u8>) -> Color {
            Color { gui, cterm }
        }

        fn normal<T: Display>(c: T) -> ColorCode<T> {
            ColorCode::Normal(c)
        }

        fn contrast<T: Display>(high: T, low: T) -> ColorCode<T> {
            ColorCode::Contrast(high, low)
        }

        let mut m = HashMap::new();
        m.insert("bg",         color(contrast("#132132", "#334152"), normal(233)));
        m.insert("bgemphasis", color(normal("#3a4b5c"),              normal(235)));
        m.insert("bgstrong",   color(normal("#536273"),              normal(238)));
        m.insert("fg",         color(normal("#fffeeb"),              contrast(231, 230)));
        m.insert("hiddenfg",   color(normal("#607080"),              normal(60)));
        m.insert("weakfg",     color(normal("#8d9eb2"),              normal(103)));
        m.insert("weakerfg",   color(normal("#788898"),              normal(102)));
        m.insert("palepink",   color(normal("#e7c6b7"),              normal(181)));
        m.insert("yellow",     color(normal("#f0eaaa"),              normal(229)));
        m.insert("white",      color(normal("#ffffff"),              normal(231)));
        m.insert("purple",     color(normal("#e7d5ff"),              normal(189)));
        m.insert("gray",       color(normal("#545f6e"),              normal(59)));
        m.insert("light",      color(normal("#646f7c"),              normal(60)));
        m.insert("yaezakura",  color(normal("#70495d"),              normal(95)));
        m.insert("sakura",     color(normal("#a9667a"),              normal(132)));
        m.insert("orange",     color(normal("#f0aa8a"),              normal(216)));
        m.insert("green",      color(normal("#a9dd9d"),              normal(150)));
        m.insert("darkgreen",  color(normal("#5f8770"),              normal(65)));
        m.insert("skyblue",    color(normal("#a8d2eb"),              normal(153)));
        m.insert("gold",       color(normal("#fedf81"),              normal(222)));
        m.insert("darkgold",   color(normal("#685800"),              normal(58)));
        m.insert("red",        color(normal("#fd8489"),              normal(210)));
        m.insert("mildred",    color(normal("#ab6560"),              normal(167)));
        m.insert("crimson",    color(normal("#ff6a6f"),              normal(203)));
        m.insert("mikan",      color(normal("#fb8965"),              normal(209)));
        m.insert("darkblue",   color(normal("#00091e"),              normal(235)));
        m.insert("blue",       color(normal("#7098e6"),              normal(69)));
        m.insert("paleblue",   color(normal("#98b8e6"),              normal(111)));
        m.insert("lime",       color(normal("#c9fd88"),              normal(149)));
        m.insert("inu",        color(normal("#ddbc96"),              normal(180)));
        m
    };
}

#[cfg_attr(rustfmt, rustfmt_skip)]
static HIGHLIGHTS: &'static [HowToHighlight] = &[
    // Normal colors
    Always(fgbg!("Boolean",               red,        NONE,         Nothing)),
    Always(fgbg!("Character",             green,      NONE,         Nothing)),
    Always(fgbg!("ColorColumn",           NONE,       bgstrong,     Nothing)),
    Always(fgbg!("Comment",               weakfg,     NONE,         CommentItalic)),
    Always(fgbg!("Conceal",               mikan,      bg,           Nothing)),
    Always(fgbg!("Conditional",           skyblue,    NONE,         Nothing)),
    Always(fgbg!("Constant",              red,        NONE,         Nothing)),
    Always(fgbg!("Cursor",                bg,         fg,           Nothing)),
    Always(fgbg!("CursorColumn",          NONE,       bgemphasis,   Nothing)),
    Always(fgbg!("CursorLine",            NONE,       bgemphasis,   None)),
    Always(fgbg!("CursorLineNr",          purple,     bgstrong,     Nothing)),
    Always(fgbg!("Define",                orange,     NONE,         Nothing)),
    Always(fgbg!("Directory",             green,      NONE,         Nothing)),
    Always(fgbg!("EndOfBuffer",           bgstrong,   NONE,         Nothing)),
    Always(fgbg!("Error",                 red,        bgemphasis,   Bold)),
    Always(fgbg!("ErrorMsg",              red,        bg,           Bold)),
    Always(fgbg!("Float",                 red,        NONE,         Nothing)),
    Always(fgbg!("FoldColumn",            purple,     bgemphasis,   Nothing)),
    Always(fgbg!("Folded",                purple,     light,        Nothing)),
    Always(fgbg!("Function",              orange,     NONE,         Nothing)),
    Always(fgbg!("Identifier",            gold,       NONE,         Italic)),
    Always(fgbg!("IncSearch",             NONE,       sakura,       Underline)),
    Always(fgbg!("Keyword",               yellow,     NONE,         Bold)),
    Always(fgbg!("Label",                 skyblue,    NONE,         Nothing)),
    Always(fgbg!("LineNr",                weakerfg,   bgemphasis,   Nothing)),
    Always(fgbg!("MatchParen",            bg,         sakura,       Underline)),
    Always(fgbg!("ModeMsg",               gold,       NONE,         Nothing)),
    Always(fgbg!("MoreMsg",               green,      NONE,         Nothing)),
    Always(fgbg!("NonText",               light,      NONE,         Nothing)),
    Always(fgbg!("Normal",                fg,         bg,           Nothing)),
    Always(fgbg!("Number",                red,        NONE,         Nothing)),
    Always(fgbg!("Operater",              orange,     NONE,         Nothing)),
    Always(fgbg!("Pmenu",                 purple,     bgemphasis,   Nothing)),
    Always(fgbg!("PmenuSbar",             gold,       bgstrong,     Nothing)),
    Always(fgbg!("PmenuSel",              gold,       bgstrong,     Nothing)),
    Always(fgbg!("PmenuThumb",            gold,       weakfg,       Nothing)),
    Always(fgbg!("PreProc",               orange,     NONE,         Nothing)),
    Always(fgbg!("Question",              skyblue,    NONE,         Nothing)),
    Always(fgbg!("Search",                NONE,       yaezakura,    Underline)),
    Always(fgbg!("SignColumn",            NONE,       bgemphasis,   Nothing)),
    Always(fgbg!("Special",               yellow,     NONE,         Bold)),
    Always(fgbg!("SpecialKey",            hiddenfg,   NONE,         Nothing)),
    Always(fgbgsp!("SpellBad",            red,        NONE, red,    Undercurl)),
    Always(fgbgsp!("SpellCap",            purple,     NONE, purple, Undercurl)),
    Always(fgbgsp!("SpellLocal",          red,        NONE, red,    Undercurl)),
    Always(fgbgsp!("SpellRare",           yellow,     NONE, yellow, Undercurl)),
    Always(fgbg!("Statement",             skyblue,    NONE,         Nothing)),
    Always(fgbg!("StatusLine",            fg,         bgstrong,     Bold)),
    Always(fgbg!("StatusLineNC",          weakfg,     bgemphasis,   None)),
    Always(fgbg!("StatusLineTerm",        fg,         bgstrong,     Bold)),
    Always(fgbg!("StatusLineTermNC",      weakfg,     bgemphasis,   None)),
    Always(fgbg!("StorageClass",          gold,       NONE,         Italic)),
    Always(fgbg!("String",                green,      NONE,         Nothing)),
    Always(fgbg!("TabLine",               weakfg,     bgstrong,     Nothing)),
    Always(fgbg!("TabLineFill",           bgemphasis, NONE,         Nothing)),
    Always(fgbg!("TabLineSel",            gold,       bg,           Bold)),
    Always(fgbg!("Tag",                   orange,     NONE,         Nothing)),
    Always(fgbg!("Title",                 gold,       NONE,         Bold)),
    Always(fgbg!("Todo",                  bg,         red,          Bold)),
    Always(fgbg!("ToolbarButton",         gold,       bg,           Bold)),
    Always(fgbg!("ToolbarLine",           weakfg,     bgstrong,     Nothing)),
    Always(fgbg!("Type",                  gold,       NONE,         Nothing)),
    Always(fgbg!("Underlined",            skyblue,    NONE,         Underline)),
    Always(fgbg!("VertSplit",             bgemphasis, bg,           Nothing)),
    Always(fgbg!("Visual",                NONE,       yaezakura,    Nothing)),
    Always(fgbg!("WarningMsg",            mikan,      bgemphasis,   Nothing)),
    Always(fgbg!("WildMenu",              NONE,       gold,         Nothing)),

    // File type specific
    //
    // Markdown is highlighted with HTML highlights in gVim but link text doesn't
    // have a color. So define it here.
    Always(fgbg!("cmakeArguments",        yellow,     NONE,         Nothing)),
    Always(fgbg!("cmakeOperators",        red,        NONE,         Nothing)),
    Always(fgbg!("DiffAdd",               NONE,       darkgreen,    Bold)),
    Always(fgbg!("DiffChange",            NONE,       darkgold,     Bold)),
    Always(fgbg!("DiffDelete",            fg,         mildred,      Bold)),
    Always(fgbg!("DiffText",              NONE,       bg,           Nothing)),
    Always(fgbg!("diffAdded",             green,      NONE,         Nothing)),
    Always(fgbg!("diffFile",              yellow,     NONE,         Nothing)),
    Always(fgbg!("diffIndexLine",         gold,       NONE,         Nothing)),
    Always(fgbg!("diffNewFile",           yellow,     NONE,         Nothing)),
    Always(fgbg!("diffRemoved",           red,        NONE,         Nothing)),
    Always(fgbg!("gitCommitOverflow",     NONE,       red,          Nothing)),
    Always(fgbg!("gitCommitSummary",      yellow,     NONE,         Nothing)),
    Always(fgbg!("gitCommitSelectedFile", skyblue,    NONE,         Nothing)),
    Always(fgbg!("gitconfigSection",      skyblue,    NONE,         Bold)),
    Always(fgbg!("goBuiltins",            red,        NONE,         Nothing)),
    Always(fgbg!("helpExample",           skyblue,    NONE,         Nothing)),
    Always(fgbg!("htmlBold",              NONE,       bgemphasis,   Nothing)),
    Always(fgbg!("htmlLinkText",          skyblue,    NONE,         Nothing)),
    Always(fgbg!("htmlTagName",           orange,     NONE,         Nothing)),
    Always(fgbg!("javaScriptBraces",      fg,         NONE,         Nothing)),
    Always(fgbg!("makeCommands",          yellow,     NONE,         Nothing)),
    Always(fgbg!("markdownCode",          yellow,     NONE,         Nothing)),
    Always(fgbg!("markdownUrl",           weakfg,     NONE,         Nothing)),
    Always(fgbg!("ocamlConstructor",      gold,       NONE,         Nothing)),
    Always(fgbg!("ocamlKeyChar",          skyblue,    NONE,         Nothing)),
    Always(fgbg!("ocamlKeyword",          gold   ,    NONE,         Nothing)),
    Always(fgbg!("ocamlFunDef",           skyblue,    NONE,         Nothing)),
    Always(fgbg!("plantumlColonLine",     skyblue,    NONE,         Nothing)),
    Always(fgbg!("pythonBuiltin",         red,        NONE,         Nothing)),
    Always(fgbg!("qfFileName",            gold,       NONE,         Nothing)),
    Always(fgbg!("qfLineNr",              skyblue,    NONE,         Nothing)),
    Always(fgbg!("rstEmphasis",           NONE,       bgemphasis,   Italic)),
    Always(fgbg!("rstStrongEmphasis",     NONE,       bgstrong,     Bold)),
    Always(fgbg!("rubyFunction",          yellow,     NONE,         Nothing)),
    Always(fgbg!("rubyIdentifier",        yellow,     NONE,         Nothing)),
    Always(fgbg!("rustEnumVariant",       gold,       NONE,         Nothing)),
    Always(fgbg!("rustFuncCall",          fg,         NONE,         Nothing)),
    Always(fgbg!("rustCommentLineDoc",    palepink,   NONE,         Nothing)),
    Always(fgbg!("typescriptBraces",      fg,         NONE,         Nothing)),
    Always(fgbg!("vimfilerColumn__SizeLine", weakfg,  NONE,         Nothing)),
    Always(fgbg!("vimfilerClosedFile",    green,      NONE,         Nothing)),
    Always(fgbg!("vimCommand",            skyblue,    NONE,         Nothing)),
    Always(fgbg!("wastListDelimiter",     fg,         NONE,         Nothing)),
    Always(fgbg!("wastInstGeneral",       yellow,     NONE,         Nothing)),
    Always(fgbg!("wastInstWithType",      yellow,     NONE,         Nothing)),
    Always(fgbg!("wastUnnamedVar"  ,      purple,     NONE,         Nothing)),
    Always(fgbg!("zshDelimiter",          skyblue,    NONE,         Nothing)),
    Always(fgbg!("zshPrecommand",         red,        NONE,         Nothing)),

    // Plugin specific
    //
    // Some plugins introduce its own highlight definitions. Adjust them for
    // working fine with this colorscheme.
    Always(fgbg!("ALEWarningSign",        orange,     bgemphasis,   Bold)),
    Always(fgbg!("ALEErrorSign",          bgemphasis, mildred,      Bold)),
    Always(fgbg!("ALEInfoSign",           NONE,       light,        Nothing)),
    Always(fgbg!("ALEError",              NONE,       mildred,      Nothing)),
    Always(fgbg!("ALEWarning",            NONE,       darkgold,     Nothing)),
    Always(fgbg!("CleverFChar",           bg,         red,          Nothing)),
    Always(fgbg!("DirvishArg",            yellow,     NONE,         Bold)),
    Always(fgbg!("EasyMotionTarget",      red,        NONE,         Bold)),
    Always(fgbg!("EasyMotionShade",       weakfg,     bg,           Nothing)),
    Always(fgbg!("GitGutterAdd",          green,      bgemphasis,   Nothing)),
    Always(fgbg!("GitGutterChange",       yellow,     bgemphasis,   Nothing)),
    Always(fgbg!("GitGutterChangeDelete", gold,       bgemphasis,   Nothing)),
    Always(fgbg!("GitGutterDelete",       red,        bgemphasis,   Nothing)),
    Always(fgbg!("HighlightedyankRegion", NONE,       bgemphasis,   Nothing)),
    Switch(
        fgbg!("EasyMotionIncCursor",      bg,         fg,           Nothing),
        fgbg!("EasyMotionIncCursor",      NONE,       NONE,         Reverse),
    ),
];

static TERM_COLORS: &'static [&'static str] = &[
    "bg",
    "crimson",
    "green",
    "gold",
    "blue",
    "purple",
    "skyblue",
    "fg",
    "bgemphasis",
    "red",
    "lime",
    "yellow",
    "paleblue",
    "palepink",
    "skyblue",
    "white",
];

fn main() -> io::Result<()> {
    write_color_scheme(&mut io::stdout(), &COLOR_TABLE)
}
