#[cfg(test)]
mod test;

use std::collections::HashMap;
use std::fmt::Display;
use std::io;

#[derive(Debug, PartialEq)]
enum ColorCode<T: Display> {
    Normal(T),
    Contrast(T, T),
}

impl<T: Display> ColorCode<T> {
    fn normal(&self) -> &T {
        match self {
            ColorCode::Normal(c) => c,
            ColorCode::Contrast(h, _) => h,
        }
    }
}

const NONE_COLOR: ColorCode<&'static str> = ColorCode::Normal("NONE");

#[derive(Debug, PartialEq)]
struct Color {
    gui: ColorCode<&'static str>,
    cterm: ColorCode<u8>,
}

type ColorTable = HashMap<&'static str, Color>;

type ColorName = Option<&'static str>;

#[derive(Debug, PartialEq)]
enum HighlightAttr {
    Nothing,
    Bold,
    Italic,
    Underline,
    Reverse,
    None,
    CommentItalic,
    Undercurl,
}

#[derive(Debug)]
struct Highlight {
    name: &'static str,
    fg: ColorName,
    bg: ColorName,
    sp: ColorName,
    attr: HighlightAttr,
}

#[derive(Debug)]
enum HowToHighlight {
    Always(Highlight),
    Switch(Highlight, Highlight),
}

use HowToHighlight::Always;
use HowToHighlight::Switch;

macro_rules! fgbg {
    ($name:expr, - , - , $attr:ident) => {
        Highlight {
            name: $name,
            fg: None,
            bg: None,
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, - , $bg:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: None,
            bg: Some(stringify!($bg)),
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, $fg:ident, - , $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: None,
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
    ($name:expr, $fg:ident, $bg:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: Some(stringify!($bg)),
            sp: None,
            attr: HighlightAttr::$attr,
        }
    };
}

macro_rules! fgbgsp {
    ($name:expr, $fg:ident, - , $sp:ident, $attr:ident) => {
        Highlight {
            name: $name,
            fg: Some(stringify!($fg)),
            bg: None,
            sp: Some(stringify!($sp)),
            attr: HighlightAttr::$attr,
        }
    };
}

#[derive(Debug)]
struct Writer<'a, W: io::Write + 'a> {
    table: ColorTable,
    highlights: &'a [HowToHighlight],
    term_colors: [&'static str; 16],
    out: &'a mut W,
}

impl<'a, W: io::Write> Writer<'a, W> {
    fn write_header(&mut self, name: &'static str) -> io::Result<()> {
        write!(
            self.out,
            r#"" {name}: Calm-colored dark color scheme
"
" Author: rhysd <lin90162@yahoo.co.jp>
" License: MIT
"   Copyright (c) 2016 rhysd
"
" PLEASE DO NOT MODIFY THIS FILE DIRECTLY!
" Generated by script vim-color-spring-night/gen/{source}

" Optimization:
" `:set background=dark` has some side effects which takes a time.
" Avoid the side effects when the value is already 'dark'.
if &background !=# 'dark'
    set background=dark
endif

" Optimization:
" `:hi clear` takes a lot of time since it clears all highlights and set default
" highlights. This guard avoids `:hi clear` on loading vimrc since in almost
" all cases no additional highlight is set at start up. Almost all additional
" highlights are set by Vim plugins.
if !has('vim_starting')
    " Remove all existing user-defined highlights and set the defaults.
    hi clear
endif

if exists('g:syntax_on')
    syntax reset
endif

let g:colors_name = '{name}'

let g:spring_night_italic_comments = get(g:, 'spring_night_italic_comments', 0)
let g:spring_night_kill_italic = get(g:, 'spring_night_kill_italic', 0)
let g:spring_night_kill_bold = get(g:, 'spring_night_kill_bold', 0)
let g:spring_night_highlight_terminal = get(g:, 'spring_night_highlight_terminal', 1)

let s:gui_running = has('gui_running')
let s:true_colors = has('termguicolors') && &termguicolors
let s:undercurl_attr = s:gui_running ? 'gui=undercurl cterm=undercurl' : 'gui=underline cterm=underline'
let s:italic_attr = g:spring_night_kill_italic ? '' : 'gui=italic'
let s:bold_attr = g:spring_night_kill_bold ? '' : 'gui=bold cterm=bold'

if exists('g:spring_night_high_contrast')
    if type(g:spring_night_high_contrast) != type(0)
        echoerr 'g:spring_night_high_contrast was changed to number value. Please read README.md of vim-color-spring-night repository and set proper value'
        let g:spring_night_high_contrast = !s:gui_running && s:true_colors
    endif
else
    let g:spring_night_high_contrast = !s:gui_running && s:true_colors
endif

"#,
            name = name,
            source = file!(),
        )
    }

    fn write_contrast_color_variables(&mut self) -> io::Result<()> {
        for (name, color) in self.table.iter() {
            if let ColorCode::Contrast(high, low) = color.gui {
                writeln!(
                    self.out,
                    "let s:{}_gui = g:spring_night_high_contrast ? '{}' : '{}'",
                    name, high, low
                )?;
            }
            if let ColorCode::Contrast(high, low) = color.cterm {
                writeln!(
                    self.out,
                    "let s:{}_cterm = g:spring_night_high_contrast ? {} : {}",
                    name, high, low
                )?;
            }
        }
        writeln!(self.out, "")
    }

    fn build_highlight_item<T: Display>(
        &self,
        color_name: &'static str,
        item_name: &'static str,
        color: &ColorCode<T>,
    ) -> String {
        match color {
            ColorCode::Normal(c) => format!("{}={}", item_name, c),
            ColorCode::Contrast(..) => if item_name.starts_with("gui") {
                format!("'{}='.s:{}_gui", item_name, color_name)
            } else {
                format!("'{}='.s:{}_cterm", item_name, color_name)
            },
        }
    }

    fn write_highlight(&mut self, highlight: &Highlight, indent: u32) -> io::Result<()> {
        let mut args = vec![highlight.name.to_string(), "term=NONE".to_string()];

        for &(color_name, gui, cterm) in &[
            (&highlight.fg, "guifg", "ctermfg"),
            (&highlight.bg, "guibg", "ctermbg"),
        ] {
            if let Some(ref name) = color_name {
                if name != &"NONE" {
                    let color = self.table.get(name).unwrap();
                    args.push(self.build_highlight_item(name, gui, &color.gui));
                    args.push(self.build_highlight_item(name, cterm, &color.cterm));
                } else {
                    args.push(self.build_highlight_item(name, gui, &NONE_COLOR));
                    args.push(self.build_highlight_item(name, cterm, &NONE_COLOR));
                }
            }
        }

        if let Some(ref name) = highlight.sp {
            // Note: ctermsp does not exist
            args.push(self.build_highlight_item(
                name,
                "guisp",
                &self.table.get(name).unwrap().gui, // Currently guisp must not be NONE
            ));
        }

        let attr_item = match highlight.attr {
            HighlightAttr::Nothing => "",
            HighlightAttr::Bold => "s:bold_attr",
            HighlightAttr::Italic => "s:italic_attr",
            HighlightAttr::Underline => "gui=underline cterm=underline",
            HighlightAttr::Reverse => "gui=reverse cterm=reverse",
            HighlightAttr::None => "gui=NONE cterm=NONE",
            HighlightAttr::CommentItalic => "g:spring_night_italic_comments ? s:italic_attr : ''",
            HighlightAttr::Undercurl => "s:undercurl_attr",
        };
        if attr_item != "" {
            args.push(attr_item.to_string());
        }

        let indent = match indent {
            0u32 => "",
            1u32 => "    ",
            _ => unreachable!(),
        };

        if args
            .iter()
            .any(|a| a.starts_with('\'') || a.ends_with('\'') || a.starts_with("s:"))
        {
            for arg in args.iter_mut() {
                if !arg.starts_with('\'') && !arg.ends_with('\'') && !arg.starts_with("s:") {
                    *arg = format!("'{}'", arg);
                }
            }
            writeln!(self.out, "{}exe 'hi' {}", indent, args.join(" "))
        } else {
            writeln!(self.out, "{}hi {}", indent, args.join(" "))
        }
    }

    fn write_highlights(&mut self) -> io::Result<()> {
        for highlight in self.highlights {
            match highlight {
                Always(ref hl) => self.write_highlight(hl, 0u32)?,
                Switch(ref gui, ref term) => {
                    writeln!(self.out, "if s:gui_running")?;
                    self.write_highlight(gui, 1u32)?;
                    writeln!(self.out, "else")?;
                    self.write_highlight(term, 1u32)?;
                    writeln!(self.out, "endif")?;
                }
            }
        }
        writeln!(self.out, "")
    }

    fn write_term_colors(&mut self) -> io::Result<()> {
        writeln!(self.out, "if has('nvim')")?;
        writeln!(self.out, "    if s:gui_running || s:true_colors")?;
        for (index, name) in self.term_colors.iter().enumerate() {
            writeln!(
                self.out,
                "        let g:terminal_color_{} = '{}'",
                index,
                self.table.get(name).unwrap().gui.normal()
            )?;
        }
        writeln!(self.out, "    else")?;
        for (index, name) in self.term_colors.iter().enumerate() {
            writeln!(
                self.out,
                "        let g:terminal_color_{} = {}",
                index,
                self.table.get(name).unwrap().cterm.normal()
            )?;
        }
        writeln!(self.out, "    endif")?;
        writeln!(self.out, "else")?;
        let elems_for_vim = self
            .term_colors
            .iter()
            .map(|name| format!("'{}'", self.table.get(name).unwrap().gui.normal()))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(
            self.out,
            "    let g:terminal_ansi_colors = [{}]",
            elems_for_vim
        )?;
        writeln!(self.out, "endif")
    }

    fn write_color_scheme(&mut self) -> io::Result<()> {
        self.write_header("spring-night")?;
        self.write_contrast_color_variables()?;
        self.write_highlights()?;
        self.write_term_colors()
    }
}

fn spring_night_writer<'a, W: io::Write + 'a>(out: &'a mut W) -> Writer<'a, W> {
    let mut table = HashMap::new();
    #[cfg_attr(rustfmt, rustfmt_skip)]
    {
        fn color(gui: ColorCode<&'static str>, cterm: ColorCode<u8>) -> Color {
            Color { gui, cterm }
        }

        fn normal<T: Display>(c: T) -> ColorCode<T> {
            ColorCode::Normal(c)
        }

        fn contrast<T: Display>(high: T, low: T) -> ColorCode<T> {
            ColorCode::Contrast(high, low)
        }

        macro_rules! color_name {
            ($name:ident, $gui:expr, $cterm:expr) => {
                assert_eq!(table.insert(stringify!($name), color($gui, $cterm)), None)
            }
        }

        color_name!(bg,         contrast("#132132", "#334152"), normal(233));
        color_name!(bgemphasis, normal("#3a4b5c"),              normal(235));
        color_name!(bgstrong,   normal("#536273"),              normal(238));
        color_name!(fg,         normal("#fffeeb"),              contrast(231, 230));
        color_name!(hiddenfg,   normal("#607080"),              normal(60));
        color_name!(weakfg,     normal("#8d9eb2"),              normal(103));
        color_name!(weakerfg,   normal("#788898"),              normal(102));
        color_name!(palepink,   normal("#e7c6b7"),              normal(181));
        color_name!(yellow,     normal("#f0eaaa"),              normal(229));
        color_name!(white,      normal("#ffffff"),              normal(231));
        color_name!(purple,     normal("#e7d5ff"),              normal(189));
        color_name!(gray,       normal("#545f6e"),              normal(59));
        color_name!(light,      normal("#646f7c"),              normal(60));
        color_name!(yaezakura,  normal("#70495d"),              normal(95));
        color_name!(sakura,     normal("#a9667a"),              normal(132));
        color_name!(orange,     normal("#f0aa8a"),              normal(216));
        color_name!(green,      normal("#a9dd9d"),              normal(150));
        color_name!(darkgreen,  normal("#5f8770"),              normal(65));
        color_name!(skyblue,    normal("#a8d2eb"),              normal(153));
        color_name!(gold,       normal("#fedf81"),              normal(222));
        color_name!(darkgold,   normal("#685800"),              normal(58));
        color_name!(red,        normal("#fd8489"),              normal(210));
        color_name!(mildred,    normal("#ab6560"),              normal(167));
        color_name!(crimson,    normal("#ff6a6f"),              normal(203));
        color_name!(mikan,      normal("#fb8965"),              normal(209));
        color_name!(darkblue,   normal("#00091e"),              normal(235));
        color_name!(blue,       normal("#7098e6"),              normal(69));
        color_name!(paleblue,   normal("#98b8e6"),              normal(111));
        color_name!(lime,       normal("#c9fd88"),              normal(149));
        color_name!(inu,        normal("#ddbc96"),              normal(180));
    }
    let table = table;

    #[cfg_attr(rustfmt, rustfmt_skip)]
    let highlights = &[
        // Normal colors
        Always(fgbg!("Boolean",               red,        -,            Nothing)),
        Always(fgbg!("Character",             green,      -,            Nothing)),
        Always(fgbg!("ColorColumn",           -,          bgstrong,     Nothing)),
        Always(fgbg!("Comment",               weakfg,     -,            CommentItalic)),
        Always(fgbg!("Conceal",               mikan,      bg,           Nothing)),
        Always(fgbg!("Conditional",           skyblue,    -,            Nothing)),
        Always(fgbg!("Constant",              red,        -,            Nothing)),
        Always(fgbg!("Cursor",                bg,         fg,           Nothing)),
        Always(fgbg!("CursorColumn",          -,          bgemphasis,   Nothing)),
        Always(fgbg!("CursorLine",            -,          bgemphasis,   None)),
        Always(fgbg!("CursorLineNr",          purple,     bgstrong,     Nothing)),
        Always(fgbg!("Define",                orange,     -,            Nothing)),
        Always(fgbg!("Directory",             green,      -,            Nothing)),
        Always(fgbg!("EndOfBuffer",           bgstrong,   -,            Nothing)),
        Always(fgbg!("Error",                 red,        bgemphasis,   Bold)),
        Always(fgbg!("ErrorMsg",              red,        bg,           Bold)),
        Always(fgbg!("Float",                 red,        -,            Nothing)),
        Always(fgbg!("FoldColumn",            purple,     bgemphasis,   Nothing)),
        Always(fgbg!("Folded",                purple,     light,        Nothing)),
        Always(fgbg!("Function",              orange,     -,            Nothing)),
        Always(fgbg!("Identifier",            gold,       -,            Italic)),
        Always(fgbg!("IncSearch",             NONE,       sakura,       Underline)),
        Always(fgbg!("Keyword",               yellow,     -,            Bold)),
        Always(fgbg!("Label",                 skyblue,    -,            Nothing)),
        Always(fgbg!("LineNr",                weakerfg,   bgemphasis,   Nothing)),
        Always(fgbg!("MatchParen",            bg,         sakura,       Underline)),
        Always(fgbg!("ModeMsg",               gold,       -,            Nothing)),
        Always(fgbg!("MoreMsg",               green,      -,            Nothing)),
        Always(fgbg!("NonText",               light,      -,            Nothing)),
        Always(fgbg!("Normal",                fg,         bg,           Nothing)),
        Always(fgbg!("Number",                red,        -,            Nothing)),
        Always(fgbg!("Operater",              orange,     -,            Nothing)),
        Always(fgbg!("Pmenu",                 purple,     bgemphasis,   Nothing)),
        Always(fgbg!("PmenuSbar",             gold,       bgstrong,     Nothing)),
        Always(fgbg!("PmenuSel",              gold,       bgstrong,     Nothing)),
        Always(fgbg!("PmenuThumb",            gold,       weakfg,       Nothing)),
        Always(fgbg!("PreProc",               orange,     -,            Nothing)),
        Always(fgbg!("Question",              skyblue,    -,            Nothing)),
        Always(fgbg!("Search",                NONE,       yaezakura,    Underline)),
        Always(fgbg!("SignColumn",            -,          bgemphasis,   Nothing)),
        Always(fgbg!("Special",               yellow,     -,            Bold)),
        Always(fgbg!("SpecialKey",            hiddenfg,   -,            Nothing)),
        Always(fgbgsp!("SpellBad",            red,        -,    red,    Undercurl)),
        Always(fgbgsp!("SpellCap",            purple,     -,    purple, Undercurl)),
        Always(fgbgsp!("SpellLocal",          red,        -,    red,    Undercurl)),
        Always(fgbgsp!("SpellRare",           yellow,     -,    yellow, Undercurl)),
        Always(fgbg!("Statement",             skyblue,    -,            Nothing)),
        Always(fgbg!("StatusLine",            fg,         bgstrong,     Bold)),
        Always(fgbg!("StatusLineNC",          weakfg,     bgemphasis,   None)),
        Always(fgbg!("StatusLineTerm",        fg,         bgstrong,     Bold)),
        Always(fgbg!("StatusLineTermNC",      weakfg,     bgemphasis,   None)),
        Always(fgbg!("StorageClass",          gold,       -,            Italic)),
        Always(fgbg!("String",                green,      -,            Nothing)),
        Always(fgbg!("TabLine",               weakfg,     bgstrong,     Nothing)),
        Always(fgbg!("TabLineFill",           bgemphasis, -,            Nothing)),
        Always(fgbg!("TabLineSel",            gold,       bg,           Bold)),
        Always(fgbg!("Tag",                   orange,     -,            Nothing)),
        Always(fgbg!("Title",                 gold,       -,            Bold)),
        Always(fgbg!("Todo",                  bg,         red,          Bold)),
        Always(fgbg!("ToolbarButton",         gold,       bg,           Bold)),
        Always(fgbg!("ToolbarLine",           weakfg,     bgstrong,     Nothing)),
        Always(fgbg!("Type",                  gold,       -,            Nothing)),
        Always(fgbg!("Underlined",            skyblue,    -,            Underline)),
        Always(fgbg!("VertSplit",             bgemphasis, bg,           Nothing)),
        Always(fgbg!("Visual",                -,          yaezakura,    Nothing)),
        Always(fgbg!("WarningMsg",            mikan,      bgemphasis,   Nothing)),
        Always(fgbg!("WildMenu",              -,          gold,         Nothing)),

        // File type specific
        //
        // Markdown is highlighted with HTML highlights in gVim but link text doesn't
        // have a color. So define it here.
        Always(fgbg!("cmakeArguments",        yellow,     -,            Nothing)),
        Always(fgbg!("cmakeOperators",        red,        -,            Nothing)),
        Always(fgbg!("DiffAdd",               -,          darkgreen,    Bold)),
        Always(fgbg!("DiffChange",            -,          darkgold,     Bold)),
        Always(fgbg!("DiffDelete",            fg,         mildred,      Bold)),
        Always(fgbg!("DiffText",              -,          bg,           Nothing)),
        Always(fgbg!("diffAdded",             green,      -,            Nothing)),
        Always(fgbg!("diffFile",              yellow,     -,            Nothing)),
        Always(fgbg!("diffIndexLine",         gold,       -,            Nothing)),
        Always(fgbg!("diffNewFile",           yellow,     -,            Nothing)),
        Always(fgbg!("diffRemoved",           red,        -,            Nothing)),
        Always(fgbg!("gitCommitOverflow",     -,          red,          Nothing)),
        Always(fgbg!("gitCommitSummary",      yellow,     -,            Nothing)),
        Always(fgbg!("gitCommitSelectedFile", skyblue,    -,            Nothing)),
        Always(fgbg!("gitconfigSection",      skyblue,    -,            Bold)),
        Always(fgbg!("goBuiltins",            red,        -,            Nothing)),
        Always(fgbg!("helpExample",           skyblue,    -,            Nothing)),
        Always(fgbg!("htmlBold",              -,          bgemphasis,   Nothing)),
        Always(fgbg!("htmlLinkText",          skyblue,    -,            Nothing)),
        Always(fgbg!("htmlTagName",           orange,     -,            Nothing)),
        Always(fgbg!("javaScriptBraces",      fg,         -,            Nothing)),
        Always(fgbg!("makeCommands",          yellow,     -,            Nothing)),
        Always(fgbg!("markdownCode",          yellow,     -,            Nothing)),
        Always(fgbg!("markdownUrl",           weakfg,     -,            Nothing)),
        Always(fgbg!("ocamlConstructor",      gold,       -,            Nothing)),
        Always(fgbg!("ocamlKeyChar",          skyblue,    -,            Nothing)),
        Always(fgbg!("ocamlKeyword",          gold   ,    -,            Nothing)),
        Always(fgbg!("ocamlFunDef",           skyblue,    -,            Nothing)),
        Always(fgbg!("plantumlColonLine",     skyblue,    -,            Nothing)),
        Always(fgbg!("pythonBuiltin",         red,        -,            Nothing)),
        Always(fgbg!("qfFileName",            gold,       -,            Nothing)),
        Always(fgbg!("qfLineNr",              skyblue,    -,            Nothing)),
        Always(fgbg!("rstEmphasis",           -,          bgemphasis,   Italic)),
        Always(fgbg!("rstStrongEmphasis",     -,          bgstrong,     Bold)),
        Always(fgbg!("rubyFunction",          yellow,     -,            Nothing)),
        Always(fgbg!("rubyIdentifier",        yellow,     -,            Nothing)),
        Always(fgbg!("rustEnumVariant",       gold,       -,            Nothing)),
        Always(fgbg!("rustFuncCall",          fg,         -,            Nothing)),
        Always(fgbg!("rustCommentLineDoc",    palepink,   -,            Nothing)),
        Always(fgbg!("typescriptBraces",      fg,         -,            Nothing)),
        Always(fgbg!("vimfilerColumn__SizeLine", weakfg,  -,            Nothing)),
        Always(fgbg!("vimfilerClosedFile",    green,      -,            Nothing)),
        Always(fgbg!("vimCommand",            skyblue,    -,            Nothing)),
        Always(fgbg!("wastListDelimiter",     fg,         -,            Nothing)),
        Always(fgbg!("wastInstGeneral",       yellow,     -,            Nothing)),
        Always(fgbg!("wastInstWithType",      yellow,     -,            Nothing)),
        Always(fgbg!("wastUnnamedVar"  ,      purple,     -,            Nothing)),
        Always(fgbg!("zshDelimiter",          skyblue,    -,            Nothing)),
        Always(fgbg!("zshPrecommand",         red,        -,            Nothing)),

        // Plugin specific
        //
        // Some plugins introduce its own highlight definitions. Adjust them for
        // working fine with this colorscheme.
        Always(fgbg!("ALEWarningSign",        orange,     bgemphasis,   Bold)),
        Always(fgbg!("ALEErrorSign",          bgemphasis, mildred,      Bold)),
        Always(fgbg!("ALEInfoSign",           -,          light,        Nothing)),
        Always(fgbg!("ALEError",              -,          mildred,      Nothing)),
        Always(fgbg!("ALEWarning",            -,          darkgold,     Nothing)),
        Always(fgbg!("CleverFChar",           bg,         red,          Nothing)),
        Always(fgbg!("DirvishArg",            yellow,     -,            Bold)),
        Always(fgbg!("EasyMotionTarget",      red,        -,            Bold)),
        Always(fgbg!("EasyMotionShade",       weakfg,     bg,           Nothing)),
        Always(fgbg!("GitGutterAdd",          green,      bgemphasis,   Nothing)),
        Always(fgbg!("GitGutterChange",       yellow,     bgemphasis,   Nothing)),
        Always(fgbg!("GitGutterChangeDelete", gold,       bgemphasis,   Nothing)),
        Always(fgbg!("GitGutterDelete",       red,        bgemphasis,   Nothing)),
        Always(fgbg!("HighlightedyankRegion", -,          bgemphasis,   Nothing)),
        Switch(
            fgbg!("EasyMotionIncCursor",      bg,         fg,           Nothing),
            fgbg!("EasyMotionIncCursor",      -,          -,            Reverse),
        ),
    ];

    let term_colors = [
        "bg",
        "crimson",
        "green",
        "gold",
        "blue",
        "purple",
        "skyblue",
        "fg",
        "bgemphasis",
        "red",
        "lime",
        "yellow",
        "paleblue",
        "palepink",
        "skyblue",
        "white",
    ];

    return Writer {
        table,
        highlights,
        term_colors,
        out,
    };
}

fn main() -> io::Result<()> {
    spring_night_writer(&mut io::stdout()).write_color_scheme()
}
